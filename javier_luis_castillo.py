# -*- coding: utf-8 -*-
"""Javier Luis Castillo.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/11l1JXcYcrGmkNzFh0KTLQeaV41eSogpA
"""

# Javier Luis Castillo Solorzano
# A01658415

"""# Actividad 2: PSAs y búsqueda
Esta actividad busca crear un Agente inteligente que represente el movimiento de un caballo en un tablero de ajedrez de dimensiones 4x4 cuyo objetivo es psar por todas las celdas que estan marcadas como `llenas`.


"""

!pip install simpleai

#---------------------------------------------------------------------------------------------------------------
#   Importación de librerías
#---------------------------------------------------------------------------------------------------------------

from simpleai.search import SearchProblem, iterative_limited_depth_first, limited_depth_first, breadth_first, uniform_cost, greedy, astar
from simpleai.search.viewers import BaseViewer, ConsoleViewer, WebViewer

#---------------------------------------------------------------------------------------------------------------
#   Definición del problema
#---------------------------------------------------------------------------------------------------------------
caballo = {          # Creamos un diccionario con los posibles movimientos de
    1: [10, 7],      # acuerdo a las posiciones del tablero 4x4
    2: [9, 11, 8],
    3: [12, 5, 10],
    4: [6, 11],
    5: [3, 11, 14],
    6: [4, 11, 15, 13],
    7: [1, 9, 14, 16],
    8: [2, 10, 15],
    9: [2, 7, 15],
    10: [8, 16, 1, 3],
    11: [2, 4, 5, 13],
    12: [3, 6, 14],
    13: [6, 11],
    14: [5, 7, 12],
    15: [8, 9, 6],
    16: [7, 10]
}

class Tablero(SearchProblem):     #Creamos la calse Tablero como nuestro PSA
    def __init__(self, inicio, meta):
        # Llama al constructor de su superclase SearchProblem (estado inicial = ciudad de inicio).
        super(Tablero, self).__init__(initial_state= (inicio, ))
        self.meta = set(meta)

    def actions(self, state):    #Creamos el método actions el cual devuelve las acciones
        posicion = state[-1]     #posibles en el estado actual
        return caballo.get(posicion, [])

    def result(self, state, action): #Definimos el metodo resultados que devuelve el estado
        return state + (action,)     #despues de realizar la accion

    def is_goal(self, state):
        return self.meta.issubset(state)

    def cost(self, state, action, state2):  #Todos los costos tienen un valor==1
        if action not in self.meta:
            return 2
        return 1

    def heuristic(self, state):             #Establecemos la heuristica la cual es la cantidad de
        return len(self.meta - set(state))  #celdas que faltan por recorrer menos el estado.

def display(result):
    if result is not None:
        for i, (action, state) in enumerate(result.path()):
            if action == None:
                print('Estado inicial')
            elif i == len(result.path()) - 1:
                print(i,'- Despues de moverse a', action)
                print('¡Meta lograda con costo =', result.cost,'!')
            else:
                print(i,'- Despues de moverse a', action)

            print('  ', state)
    else:
        print('Error!')

#---------------------------------------------------------------------------------------------------------------
#   Solución del problema con diferentes métodos
#---------------------------------------------------------------------------------------------------------------

# posibles expectadores para las búsquedas
my_viewer = None
#my_viewer = BaseViewer()       # Solo estadísticas
#my_viewer = ConsoleViewer()    # Texto en la consola
#my_viewer = WebViewer()        # Abrir en un browser en la liga http://localhost:8000

# despliega el resultado de la búsqueda primero en anchura
print()
print('>> Busqueda Primero en Anchura <<')
result = breadth_first(Tablero(inicio=1,meta=[3,2]), graph_search=False, viewer=my_viewer)
display(result)
if my_viewer != None:
    print('Stats:')
    print(my_viewer.stats)

# resuelve el problema utilizando búsqueda de grafo con el algoritmo de
# profundiad iterativa limitada
result = iterative_limited_depth_first(Tablero(inicio=1,meta=[3,2]), graph_search=True)
print()
print('>> Busqueda de Profundidad Iterativa limitada <<')
display(result)
if my_viewer != None:
    print('Stats:')
    print(my_viewer.stats)

# resuelve el problema utilizando búsqueda de grafo con el algoritmo de
# costo uniforme
result = uniform_cost(Tablero(inicio=1, meta=[3, 2]), graph_search=True)
print()
print('>> Busqueda de Costo Uniforme <<')
display(result)
if my_viewer is not None:
    print('Stats:')
    print(my_viewer.stats)

result = limited_depth_first(Tablero(inicio=1, meta=[3, 2]), 6)
print()
print('>> Busqueda con Limite de Profundidad <<')
display(result)
if my_viewer is not None:
    print('Stats:')
    print(my_viewer.stats)

# resuelve el problema utilizando búsqueda de grafo con el algoritmo de
# A*.
result = astar(Tablero(inicio=1,meta=[3,2]), graph_search=True)
print()
print('>> Busqueda A* <<')
display(result)
if my_viewer != None:
    print('Stats:')
    print(my_viewer.stats)

# resuelve el problema utilizando búsqueda greedy
result = greedy(Tablero(inicio=1, meta=[3, 2]), graph_search=True)
print()
print('>> Busqueda Greedy <<')
display(result)
if my_viewer is not None:
    print('Stats:')
    print(my_viewer.stats)


#---------------------------------------------------------------------------------------------------------------
#   Fin del archivo
#---------------------------------------------------------------------------------------------------------------

"""# Heurística
La heurística que estamos aplicando es solamente admisible con el metodo de A*, ya que si asegura que este encuentre el método óptimo. Por el contrario, con el metodo *Greedy* no encuentra la solución óptima.

Esta heurística es consistente ya que asegura que el costo de cada nodo no disminuye más rápido de lo que disminuye la heurística.

# Observación y Conclusión
El desarrollo de el PSA de este tipo resulta muy util para poder encontrar la solución a problemas sencillos como este, sin embargo cuando un problema se convierte en uno más complejo o escalable quisás la programacion del PSA no sea programable por medio de diccionarios. Tomando en cuenta la solución a la cual llegué después de prueba, error y múltiples intentos, el diccionario de acciones es la solución más sencilla para este problema.

En cuanto al establecimiento de los estados y acciones, tener una plantilla la cuál puedes usar para crear tu PSA resultó de suma importancia. Lograr entender como funciona la programación de un PSA me pareció muy interesante, y poder aplicarlo en algún punto en proyectos más grandes y de mayor complejidad suena cada vez más interesante. Igualmente, lograr buscar cuál es la soulción óptima a este problema sencillo y de baja complejidad me demostró como los diferentes métodos de busqueda tienen sus ventajas. Igualmente, en este pequeño proyecto me doy cuenta que la heurística puede facilitar el proceso de encontrar una solución óptima (como en la búsqueda A-estrella) así como puede salir contraproducente en la búsquda de la solución óptima.

Para concluir, termino muy contento de la experiencia que tuve durante el desarrollo de esta actividad, entendiendo la creación de un PSA, así como la de un árbol de busquda utilizando librerías de apoyo. Me voy con muchos conocimientos, pero sobre todo me voy con un nuevo reto personal a cumplir: crear mi propio agente inteligente que pueda ser escalable y funcional, buscando una complejidad de tiempo y espacio lógica, pero sobre todo, que pueda resolver los diversos problemas e inquitudes que me surgieron durante el desarrollo de esta Actividad.

"""